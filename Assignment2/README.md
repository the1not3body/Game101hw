MSAA 黑边的问题
https://zhuanlan.zhihu.com/p/454001952
为了解决这个问题，我们可以在光栅化的时候，确保边界上的每个三角形的每个小像素都被考虑到，即在过完每个 边界上的像素后，我们确保记录下它的frame buffer，并清除它的depth buffer。这样上图的蓝色小像素就不会因为depth_buf的原因，而没被记录。如何确定哪个像素在边界上？通过在三角形的小像素的个数]

https://blog.csdn.net/weixin_51928794/article/details/117256226
1. 在计算完绿色三角形后，帧缓存和深度均已更新，三角形边缘的地方像素颜色采用覆盖比率插值计算，深度值为绿色三角形在该坐标所计算出的深度插值。根据上面的话，这条黑色的边其实并不是真的的黑色，而是插值之后的绿色，只不过是由于覆盖比率很小在插值之后rgb值变得很低，颜色的饱和度与亮度会随之下降。例如原rgb值为（200,200,100），若覆盖比率为4/16的话，如下面效果，若覆盖率更低那么会更接近黑色。在计算完第一个绿色的三角形之后，开始计算第二个蓝色的三角形，这时又遍历到了上面异常的黑边处，也就是有一点点绿色的黑边，需要比较深度缓存来决定蓝色三角形是否要在该像素绘制。在每个像素采样计算时，三角形的覆盖是按照4x4采样计算的，但是深度值是按照像素级别1x1计算和存储来的， 之前该像素位置只存储了绿色三角形的深度值，蓝色三角形在绿色之后，所以深度比较失败，从而导致了该处不会再更新像素值。

如果只使用与图像大小同样的帧缓冲空间和深度缓冲空间，上述情况可能是无解的，也就是边缘处靠后绘制的图像若位置也在后面（深度差值比较失败）将无法更新像素值从而产生“黑边”，如果有请告诉我！
上述的情况是因为深度缓冲采样率不足所导致的，所以按照采样率扩大深度缓存空间。这个时候在计算深度缓存的时候一个像素是按照4x4频率来计算的，可以存储多个深度值并更新和计算各个三角形的边缘像素的覆盖比率。
